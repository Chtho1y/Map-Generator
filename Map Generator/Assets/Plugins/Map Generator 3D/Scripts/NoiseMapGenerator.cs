using UnityEngine;
using System.Collections;
using System.Collections.Generic;

/// <summary>
/// Draws the mesh generated by "NoiseMesgGenerator.cs" static class based on noise data generated by "Noise.cs" static class. Exposes the needed params to create diferent terrain alike surfaces.
/// </summary>

namespace CNB
{
	public class NoiseMapGenerator : MonoBehaviour
	{
		[HideInInspector]
		public bool generateFloor = true;

		[HideInInspector]
		public int mapWidth;

		[HideInInspector]
		public int mapHeight;

		[Range(1, 500)]
		public float mapHeightScale;
		[Range(2, 500)]
		public float noiseScale;
		[Range(3, 6)]
		public int octaves;
		[Range(0, 1)]
		public float persistance;
		[Range(4, 10)]
		public float lacunarity;

		public int seed;
		public Vector2 offset;

		[HideInInspector]
		public bool autoUpdate;

		[HideInInspector]
		public MapGeneratorCNB _mapGeneratorCNB;

		[HideInInspector]
		public MeshFilter _meshFilter;

		Mesh _sharedMesh;

		MeshCollider meshCollFloor;

		void DrawMesh(MeshData meshData)
		{
			_sharedMesh = meshData.CreateMesh(mapWidth,mapHeight);
			MeshCollider col = this.GetComponent<MeshCollider>();
            if (col)
            {
                if (_meshFilter==null)
                {
					_meshFilter = gameObject.GetComponent<MeshFilter>();
				}
				 _meshFilter.sharedMesh = _sharedMesh;
				col.sharedMesh = _meshFilter.sharedMesh;
			}
		}
		public void GenerateMap()
		{
			if (generateFloor)
			{
				_mapGeneratorCNB = GameObject.FindGameObjectWithTag("MapSO").GetComponent<MapGeneratorCNB>();
				meshCollFloor = this.GetComponent<MeshCollider>();
				if (meshCollFloor == null)
				{
					meshCollFloor = this.gameObject.AddComponent<MeshCollider>();
				}
				meshCollFloor.sharedMesh=_sharedMesh;
				if (_mapGeneratorCNB != null)
				{
					mapWidth = _mapGeneratorCNB._map._width + _mapGeneratorCNB._borderMap * 2;
					mapHeight = _mapGeneratorCNB._map._height + _mapGeneratorCNB._borderMap * 2;

					float[,] noiseMap = Noise.GenerateNoiseMap(mapWidth, mapHeight, seed, noiseScale, octaves, persistance, lacunarity, offset);

					DrawMesh(NoiseMeshGenerator.GenerateTerrainMesh(noiseMap, mapHeightScale));
					Vector3 newLocalScale = Vector3.one * _mapGeneratorCNB._map._squareSize;
					this.transform.localScale = newLocalScale;
				}
			}
		}

		public void SetNoiseFloors()
		{
            if (_mapGeneratorCNB= null)
            {
				_mapGeneratorCNB = GameObject.FindGameObjectWithTag("MapSO").GetComponent<MapGeneratorCNB>();
				_mapGeneratorCNB._mapNoiseFloors.Clear();
			}
			List<NoiseMapGenerator> noiseGenerators = new List<NoiseMapGenerator>();
			GameObject[] noiseGOs = GameObject.FindGameObjectsWithTag("NoiseFloor");
			foreach (var item in noiseGOs)
			{
                if (_mapGeneratorCNB==null)
                {
					_mapGeneratorCNB = GameObject.FindGameObjectWithTag("MapSO")? GameObject.FindGameObjectWithTag("MapSO").GetComponent<MapGeneratorCNB>():null;
				}
                if (_mapGeneratorCNB!=null)
                {
					_mapGeneratorCNB._mapNoiseFloors.Add(item);
				}
				
				NoiseMapGenerator nmp = item.GetComponent<NoiseMapGenerator>();
				if (nmp)
				{
					noiseGenerators.Add(nmp);
				}
			}
			foreach (var item in noiseGenerators)
			{
				item.GenerateMap();
			}
		}

		void OnValidate()
		{
			if (mapWidth < 1)
			{
				mapWidth = 1;
			}
			if (mapHeight < 1)
			{
				mapHeight = 1;
			}
			if (lacunarity < 1)
			{
				lacunarity = 1;
			}
			if (octaves < 0)
			{
				octaves = 0;
			}
		}
	}
}